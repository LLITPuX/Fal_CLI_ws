---
description: Clerk Agent (–ü–∏—Å–∞—Ä—å) patterns and best practices
alwaysApply: false
---
# CLERK AGENT (–ü–ò–°–ê–†–¨) RULES

## Purpose

–ü–∏—Å–∞—Ä—å - –ø–µ—Ä—à–∏–π –∞–≥–µ–Ω—Ç –≤ –º—É–ª—å—Ç–∏–∞–≥–µ–Ω—Ç–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ. –ô–æ–≥–æ –Ñ–î–ò–ù–ê –∑–∞–¥–∞—á–∞: –∑–∞–ø–∏—Å—É–≤–∞—Ç–∏ –∫–æ–∂–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (user —Ç–∞ assistant) –≤ FalkorDB –±–µ–∑ –±—É–¥—å-—è–∫–æ—ó –æ–±—Ä–æ–±–∫–∏.

---

## Responsibility (Single Responsibility Principle)

### ‚úÖ –¢–Ü–õ–¨–ö–ò –¶–ï:

1. **–û—Ç—Ä–∏–º–∞—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è** –∑ state
2. **–°—Ç–≤–æ—Ä–∏—Ç–∏ ChatMessage** object
3. **–ó–∞–ø–∏—Å–∞—Ç–∏ –≤ FalkorDB** —á–µ—Ä–µ–∑ repository
4. **–û–Ω–æ–≤–∏—Ç–∏ state** –∑ message_id —Ç–∞ recorded=True

### ‚ùå –ó–ê–ë–û–†–û–ù–ï–ù–û:

- ‚ùå –ê–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ –∫–æ–Ω—Ç–µ–Ω—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
- ‚ùå –ó–º—ñ–Ω—é–≤–∞—Ç–∏ —Ç–µ–∫—Å—Ç
- ‚ùå –ü—Ä–∏–π–º–∞—Ç–∏ —Ä—ñ—à–µ–Ω–Ω—è
- ‚ùå –ì–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
- ‚ùå –®—É–∫–∞—Ç–∏ –∑–≤'—è–∑–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏
- ‚ùå –§—ñ–ª—å—Ç—Ä—É–≤–∞—Ç–∏ –∞–±–æ –≤–∞–ª—ñ–¥—É–≤–∞—Ç–∏ –∫–æ–Ω—Ç–µ–Ω—Ç (—Ü–µ API layer)

**–ú–µ—Ç–∞—Ñ–æ—Ä–∞:** –î—Ä–µ–≤–Ω—ñ–π –ø–∏—Å–∞—Ä –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–ø–∏—Å—É—î —Ç–µ–∫—Å—Ç, –Ω–µ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç—É—î –π–æ–≥–æ.

---

## Module Structure

```
backend/app/agents/clerk/
‚îú‚îÄ‚îÄ __init__.py           # Public API
‚îú‚îÄ‚îÄ schemas.py            # ChatMessage, ChatSession
‚îú‚îÄ‚îÄ repository.py         # FalkorDB CRUD
‚îî‚îÄ‚îÄ nodes.py              # clerk_record_node
```

### File Responsibilities

**schemas.py:**
- Define ChatMessage (id, content, role, timestamp, status)
- Define ChatSession (id, created_at, user_id, title, status)
- Pydantic models with validation

**repository.py:**
- create_session() - CREATE (:ChatSession)
- create_message() - CREATE (:Message)-[:IN_SESSION]->(:ChatSession)
- get_session_messages() - MATCH and retrieve history
- update_message_status() - SET m.status

**nodes.py:**
- clerk_record_node() - LangGraph node function

---

## Node Implementation

### Standard Pattern

```python
async def clerk_record_node(state: dict, repository: MessageRepository) -> dict:
    """Record message to FalkorDB without processing.
    
    Args:
        state: Current state from LangGraph
        repository: MessageRepository for DB operations
        
    Returns:
        Updated state with recording results
    """
    logger.info("üìù –ü–∏—Å–∞—Ä—å: –ü–æ—á–∏–Ω–∞—é –∑–∞–ø–∏—Å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...")
    
    try:
        # 1. Create message from state
        message = ChatMessage(
            content=state["message_content"],
            role=state["message_role"],
            session_id=state["session_id"],
            timestamp=datetime.now(),
            status="recorded",
            metadata=state.get("metadata", {}),
        )
        
        # 2. Save to FalkorDB
        message_id = await repository.create_message(message)
        
        # 3. Update state
        state["message_id"] = message_id
        state["recorded"] = True
        state["error"] = None
        
        logger.info(
            f"üìù –ü–∏—Å–∞—Ä—å —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø–∏—Å–∞–≤: {message_id} "
            f"(role={message.role}, length={len(message.content)})"
        )
        
    except Exception as e:
        logger.error(f"üìù –ü–∏—Å–∞—Ä—å: –ü–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Å—É: {e}", exc_info=True)
        state["recorded"] = False
        state["error"] = f"Recording failed: {str(e)}"
    
    return state
```

**KEY POINTS:**
- Input: dict (LangGraph format)
- Output: dict (modified, not replaced)
- Dependency injection —á–µ—Ä–µ–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä
- Detailed logging –∑ emoji prefix
- Graceful error handling

---

## Repository Pattern

### CRUD Operations

**create_message():**
```python
async def create_message(self, message: ChatMessage) -> str:
    """Record message to FalkorDB."""
    cypher = """
    MATCH (s:ChatSession {id: $session_id})
    CREATE (m:Message {
        id: $id,
        content: $content,
        role: $role,
        timestamp: $timestamp,
        status: $status,
        metadata: $metadata
    })
    CREATE (m)-[:IN_SESSION]->(s)
    RETURN m.id as id
    """
    
    params = {
        "id": message.id,
        "content": message.content,
        "role": message.role,
        "timestamp": message.timestamp.isoformat(),  # ISO string!
        "session_id": message.session_id,
        "status": message.status,
        "metadata": str(message.metadata),  # FalkorDB –Ω–µ –ª—é–±–∏—Ç—å nested dicts
    }
    
    results, exec_time = await self.client.query(cypher, params)
    logger.info(f"üìù –ü–∏—Å–∞—Ä—å –∑–∞–ø–∏—Å–∞–≤: {message.id} ({exec_time:.2f}ms)")
    
    return results[0]["id"] if results else message.id
```

**CRITICAL LESSONS:**

1. **Timestamps —è–∫ ISO strings** - FalkorDB –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î datetime() function
   ```python
   # ‚ùå WRONG
   timestamp: datetime($timestamp)
   
   # ‚úÖ CORRECT
   timestamp: $timestamp  # Pass as ISO string
   ```

2. **Metadata —è–∫ string** - FalkorDB –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î nested objects
   ```python
   metadata: str(message.metadata)  # Convert to string
   ```

3. **Always use parameterized queries** - –Ω—ñ–∫–æ–ª–∏ f-strings –∑ user input

---

## FalkorDB Schema

### Nodes

```cypher
// ChatSession
(:ChatSession {
  id: "uuid",              // UUID hex
  created_at: "ISO8601",   // String, not datetime!
  user_id: "identifier",
  title: "optional",
  status: "active|archived",
  metadata: "{}"           // JSON string
})

// Message  
(:Message {
  id: "uuid",
  content: "text",
  role: "user|assistant|system",
  timestamp: "ISO8601",    // String, not datetime!
  status: "recorded|analyzed|responded",
  metadata: "{}"
})
```

### Relationships

```cypher
// Basic (Phase 1)
(:Message)-[:IN_SESSION]->(:ChatSession)

// Future (Phase 2 - Subconscious)
(:Message)-[:FOLLOWS]->(:Message)          // –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å
(:Message)-[:REFERENCES {similarity: 0.85}]->(:Message)  // –°–µ–º–∞–Ω—Ç–∏—á–Ω–∏–π –∑–≤'—è–∑–æ–∫
```

---

## Error Handling

### Three-Layer Strategy

**1. Repository Layer ‚Üí DatabaseError**
```python
try:
    result = await self.client.query(cypher, params)
except Exception as e:
    raise DatabaseError(f"Query failed: {e}")
```

**2. Node Layer ‚Üí Update state.error**
```python
try:
    message_id = await repository.create_message(message)
    state["recorded"] = True
except DatabaseError as e:
    state["recorded"] = False
    state["error"] = str(e)
```

**3. API Layer ‚Üí HTTPException**
```python
try:
    final_state = await workflow.ainvoke(state)
    if final_state.error:
        raise HTTPException(500, detail=final_state.error)
except Exception as e:
    raise HTTPException(500, detail=str(e))
```

**NEVER let exceptions bubble unhandled!**

---

## Testing Strategy

### Unit Tests

**Test repository methods:**
```python
@pytest.mark.asyncio
async def test_create_message(mock_falkordb_client):
    repo = MessageRepository(mock_falkordb_client)
    
    message = ChatMessage(
        content="Test message",
        role="user",
        session_id="test_session"
    )
    
    message_id = await repo.create_message(message)
    
    assert message_id is not None
    mock_falkordb_client.query.assert_called_once()
```

**Test node function:**
```python
@pytest.mark.asyncio
async def test_clerk_record_node(mock_repository):
    state = {
        "message_content": "Hello",
        "message_role": "user",
        "session_id": "test123"
    }
    
    result = await clerk_record_node(state, mock_repository)
    
    assert result["recorded"] is True
    assert result["message_id"] is not None
    assert result["error"] is None
```

---

## Logging Best Practices

### Structured Logging

```python
# Always include:
logger.info(
    f"üìù –ü–∏—Å–∞—Ä—å —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø–∏—Å–∞–≤: {message_id} "
    f"(role={message.role}, "
    f"content_length={len(message.content)}, "
    f"session={message.session_id}, "
    f"time={exec_time:.2f}ms)"
)
```

**What to log:**
- ‚úÖ Message ID (–¥–ª—è tracing)
- ‚úÖ Role (user/assistant)
- ‚úÖ Content length (–Ω–µ —Å–∞–º content - privacy!)
- ‚úÖ Session ID
- ‚úÖ Execution time
- ‚úÖ Success/failure

**What NOT to log:**
- ‚ùå Full message content (–º–æ–∂–µ –º—ñ—Å—Ç–∏—Ç–∏ sensitive data)
- ‚ùå User credentials
- ‚ùå Full metadata if contains PII

---

## Performance Characteristics

### Expected Timings

**Session creation:** ~10-20ms  
**Message recording:** ~12-50ms  
**History retrieval (50 msg):** ~30-100ms

**If slower:**
- Check FalkorDB connection
- Check query complexity
- Check network latency (Docker)

### Optimization

**Already optimal:**
- ‚úÖ Parameterized queries (prepared statements)
- ‚úÖ Async execution (non-blocking)
- ‚úÖ Simple CREATE (no complex MATCH)

**Future optimization:**
- Batch inserts (—è–∫—â–æ —Ç—Ä–µ–±–∞ –∑–∞–ø–∏—Å–∞—Ç–∏ –±–∞–≥–∞—Ç–æ messages)
- Connection pooling (–≤–∂–µ —î —á–µ—Ä–µ–∑ singleton)

---

## Common Mistakes & How to Avoid

### Mistake 1: Trying to Be Smart

**WRONG:**
```python
async def clerk_record_node(state, repo):
    content = state["message_content"]
    
    # ‚ùå –ü–∏—Å–∞—Ä—å –ù–ï –ø–æ–≤–∏–Ω–µ–Ω –¥—É–º–∞—Ç–∏!
    if "bad word" in content:
        return state  # Skip recording
    
    # ‚ùå –ü–∏—Å–∞—Ä—å –ù–ï –º–æ–¥–∏—Ñ—ñ–∫—É—î!
    content = content.lower()
```

**CORRECT:**
```python
async def clerk_record_node(state, repo):
    # ‚úÖ –ü—Ä–æ—Å—Ç–æ –∑–∞–ø–∏—Å—É—î–º–æ —è–∫ —î
    message = ChatMessage(content=state["message_content"], ...)
    message_id = await repo.create_message(message)
```

### Mistake 2: Not Handling Sessions

**WRONG:**
```python
# ‚ùå –ù–µ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —ñ—Å–Ω—É—î session
cypher = "CREATE (m:Message {...})"  # No IN_SESSION relationship
```

**CORRECT:**
```python
# ‚úÖ –ó–∞–≤–∂–¥–∏ –∑–≤'—è–∑—É—î–º–æ –∑ session
cypher = """
MATCH (s:ChatSession {id: $session_id})
CREATE (m:Message {...})
CREATE (m)-[:IN_SESSION]->(s)
"""
```

**If session doesn't exist:** Query fails (by design). API layer should check before calling.

### Mistake 3: Forgetting Timestamps

**WRONG:**
```python
# ‚ùå –ó–∞–±—É–ª–∏ timestamp
message = ChatMessage(
    content=content,
    role=role,
    session_id=session_id
)
```

**CORRECT:**
```python
# ‚úÖ Timestamp –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π
message = ChatMessage(
    content=content,
    role=role,
    session_id=session_id,
    timestamp=datetime.now()  # !!
)
```

---

## Integration with Other Agents

### State Contract

**Clerk provides:**
- `message_id: str` - ID –∑–∞–ø–∏—Å–∞–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
- `recorded: bool` - —á–∏ —É—Å–ø—ñ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–æ
- `error: str | None` - –ø–æ–º–∏–ª–∫–∞ —è–∫—â–æ —î

**Clerk expects:**
- `message_content: str` - —Ç–µ–∫—Å—Ç (required)
- `message_role: str` - role (required)
- `session_id: str` - session (required)
- `metadata: dict` - optional

**Subconscious will use:**
```python
if state["recorded"]:
    message_id = state["message_id"]
    # Analyze this message
```

---

## Migration & Schema Evolution

### Adding New Fields to Message

**Safe pattern:**
```python
# 1. Update schema
class ChatMessage(BaseModel):
    # ... existing fields ...
    new_field: str | None = None  # Optional!

# 2. Update Cypher (optional field)
cypher = """
CREATE (m:Message {
    ...,
    new_field: $new_field
})
"""

# 3. Old messages –±–µ–∑ new_field - OK
```

**NEVER:**
- ‚ùå Remove existing fields
- ‚ùå Make new fields required (breaks old data)
- ‚ùå Change field types

---

## Monitoring

### Key Metrics to Track

1. **Recording success rate** - state["recorded"] = True –≤—ñ–¥—Å–æ—Ç–æ–∫
2. **Recording latency** - avg time to record
3. **Error rate** - state["error"] not None
4. **Messages per session** - avg count

### Health Check

```python
# In repository
async def health_check(self) -> bool:
    """Check if Clerk can write to DB."""
    try:
        # Try simple write
        test_message = ChatMessage(
            content="health_check",
            role="system",
            session_id="health_check"
        )
        await self.create_message(test_message)
        return True
    except:
        return False
```

---

## Security Considerations

### What Clerk Does NOT Validate

Clerk –∑–∞–ø–∏—Å—É—î –í–°–ï —è–∫ —î. Validation –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –≤ API layer!

**API layer responsibility:**
- Length limits (max 10,000 chars)
- Content sanitization (XSS)
- Rate limiting
- Auth check

**Clerk responsibility:**
- None (just record)

**WHY:** Separation of concerns. Clerk –¥–æ–≤—ñ—Ä—è—î —â–æ API –≤—ñ–¥—Ñ—ñ–ª—å—Ç—Ä—É–≤–∞–≤.

---

## Lessons Learned (Production Experience)

### Issue 1: FalkorDB datetime() Not Supported

**Problem:** `datetime($timestamp)` –≤ Cypher ‚Üí "Unknown function"

**Solution:** Store as ISO string
```python
timestamp: $timestamp  # Not datetime($timestamp)
params["timestamp"] = dt.isoformat()  # Convert to string
```

**Impact:** CRITICAL - —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –ø—Ä–∞—Ü—é–≤–∞–ª–∞ –±–µ–∑ —Ü—å–æ–≥–æ.

### Issue 2: Metadata as Nested Dict

**Problem:** FalkorDB –Ω–µ –∑–±–µ—Ä—ñ–≥–∞—î nested dicts
```python
metadata: {"user": {"ip": "..."}}  # ‚ùå Fails
```

**Solution:** Convert to string
```python
metadata: str(message.metadata)  # ‚úÖ Works
```

### Issue 3: Missing Session

**Problem:** –ù–∞–º–∞–≥–∞—î–º–æ—Å—å —Å—Ç–≤–æ—Ä–∏—Ç–∏ Message –¥–ª—è –Ω–µ—ñ—Å–Ω—É—é—á–æ—ó Session

**Solution:** API layer checks:
```python
session = await repository.get_session(session_id)
if not session:
    raise HTTPException(404, "Session not found")
```

---

## Quick Reference Checklist

**When implementing Clerk:**
- [ ] Use MessageRepository for all DB ops
- [ ] Store timestamps as ISO strings (isoformat())
- [ ] Convert metadata to string
- [ ] Create IN_SESSION relationship
- [ ] Log with "üìù –ü–∏—Å–∞—Ä—å:" prefix
- [ ] Handle errors ‚Üí update state.error
- [ ] Return dict, not Pydantic
- [ ] Never modify message content
- [ ] Never skip messages
- [ ] Never make decisions

**When debugging Clerk:**
- [ ] Check FalkorDB connection
- [ ] Check session exists
- [ ] Check timestamp format (ISO string)
- [ ] Check logs for "üìù –ü–∏—Å–∞—Ä—å"
- [ ] Check state["recorded"] and state["error"]

---

## API Integration

### Endpoint Pattern

```python
@router.post("/chat/message")
async def send_message(
    request: SendMessageRequest,
    repository: MessageRepositoryDep
):
    # 1. Validate session exists
    session = await repository.get_session(request.session_id)
    if not session:
        raise HTTPException(404, "Session not found")
    
    # 2. Create state
    initial_state = ChatState(
        message_content=request.content,
        message_role=request.role,
        session_id=request.session_id
    )
    
    # 3. Run workflow (—á–µ—Ä–µ–∑ –ü–∏—Å–∞—Ä—è)
    workflow = get_chat_workflow()
    final_state_dict = await workflow.ainvoke(initial_state)
    final_state = ChatState(**final_state_dict)  # Convert!
    
    # 4. Check result
    if final_state.error:
        raise HTTPException(500, detail=final_state.error)
    
    return ChatMessageResponse(
        message_id=final_state.message_id,
        recorded=final_state.recorded
    )
```

---

## Future Compatibility

### When Adding Subconscious

Clerk –Ω–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è! –¢—ñ–ª—å–∫–∏ workflow:

```python
# Phase 1
workflow.add_edge("clerk", END)

# Phase 2
workflow.add_edge("clerk", "subconscious")
workflow.add_edge("subconscious", END)
```

Clerk –ø—Ä–æ–¥–æ–≤–∂—É—î —Ä–æ–±–∏—Ç–∏ —Ç–µ —Å–∞–º–µ - –∑–∞–ø–∏—Å—É–≤–∞—Ç–∏.

### When Adding Orchestrator

Clerk –≤—Å–µ —â–µ –Ω–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è:

```python
# Phase 3
workflow.add_edge("clerk", "subconscious")
workflow.add_edge("subconscious", "orchestrator")
workflow.add_edge("orchestrator", END)
```

**Clerk - –Ω–∞–π—Å—Ç–∞–±—ñ–ª—å–Ω—ñ—à–∏–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç.** –Ø–∫—â–æ –≤—ñ–Ω –ø—Ä–∞—Ü—é—î –≤ Phase 1, –≤—ñ–Ω –ø—Ä–∞—Ü—é–≤–∞—Ç–∏–º–µ —ñ –≤ Phase 10.

---

## Performance Notes

**Clerk is fast:**
- Single CREATE query (~10-50ms)
- No complex logic
- No external API calls

**Bottleneck is NOT Clerk**, it will be:
- Subconscious (embeddings, similarity)
- Orchestrator (Gemini API ~1-3s)

**Don't optimize Clerk** - –≤—ñ–Ω –≤–∂–µ optimal.

---

**Version:** 1.0.0  
**Created:** November 6, 2025  
**Status:** Phase 1 implemented and tested  
**Next:** Phase 2 (Subconscious Agent)
