---
description: LangGraph workflow patterns and best practices for Cybersich agents
alwaysApply: false
---
# LANGGRAPH PATTERNS

## Purpose

–ó–∞–≥–∞–ª—å–Ω—ñ –ø—Ä–∞–≤–∏–ª–∞ —Ç–∞ patterns –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ LangGraph –≤ –º—É–ª—å—Ç–∏–∞–≥–µ–Ω—Ç–Ω—ñ–π —Å–∏—Å—Ç–µ–º—ñ Cybersich Chat.

---

## State Management

### ChatState Schema

**Location:** `backend/app/agents/state.py`

**CRITICAL RULES:**

1. **State is immutable** - –∫–æ–∂–µ–Ω node –ø–æ–≤–µ—Ä—Ç–∞—î –Ω–æ–≤–∏–π state
2. **Pydantic model required** - –¥–ª—è type safety
3. **All fields optional except inputs** - –∞–≥–µ–Ω—Ç–∏ –º–æ–∂—É—Ç—å –Ω–µ –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ –≤—Å–µ
4. **Never delete fields** - —Ç—ñ–ª—å–∫–∏ –¥–æ–¥–∞–≤–∞–π –Ω–æ–≤—ñ

**Pattern:**
```python
from pydantic import BaseModel, Field

class ChatState(BaseModel):
    # === Input (Required) ===
    message_content: str
    message_role: Literal["user", "assistant", "system"]
    session_id: str
    
    # === Agent outputs (Optional) ===
    message_id: str | None = None
    recorded: bool = False
    context: dict[str, Any] = Field(default_factory=dict)
    response: str | None = None
    error: str | None = None
    
    class Config:
        arbitrary_types_allowed = True
```

**Adding new fields (when adding new agent):**
```python
# ‚úÖ GOOD - –¥–æ–¥–∞—î–º–æ –Ω–æ–≤—ñ –ø–æ–ª—è
class ChatState(BaseModel):
    # ... existing fields ...
    
    # New agent outputs
    agent_x_result: dict = Field(default_factory=dict)  # NEW
    agent_x_completed: bool = False  # NEW
```

**‚ùå NEVER remove existing fields** - –ª–∞–º–∞—î —ñ–Ω—à–∏—Ö –∞–≥–µ–Ω—Ç—ñ–≤!

---

## Node Function Pattern

### Standard Node Signature

```python
async def agent_node(state: dict, dependencies: ...) -> dict:
    """Agent node implementation.
    
    Args:
        state: Current state as dict (LangGraph format)
        dependencies: Injected dependencies (repositories, services, etc.)
        
    Returns:
        Updated state as dict
    """
    logger.info("ü§ñ Agent: Starting...")
    
    try:
        # 1. Extract from state
        input_data = state["message_content"]
        
        # 2. Do work
        result = await do_something(input_data, dependencies)
        
        # 3. Update state
        state["agent_output"] = result
        state["agent_completed"] = True
        state["error"] = None
        
        logger.info("‚úÖ Agent: Completed successfully")
        
    except Exception as e:
        logger.error(f"‚ùå Agent: Failed - {e}", exc_info=True)
        state["agent_completed"] = False
        state["error"] = str(e)
    
    return state
```

**KEY POINTS:**
- Always return dict (–Ω–µ Pydantic model!)
- Update state, don't replace
- Handle errors gracefully
- Log before/after

---

## Workflow Definition

### Pattern

**Location:** `backend/app/agents/graph.py`

```python
from langgraph.graph import END, StateGraph
from app.agents.state import ChatState

def create_chat_workflow(
    clerk_repo: MessageRepository,
    # Future: other dependencies
) -> StateGraph:
    """Create compiled LangGraph workflow."""
    
    # Define workflow
    workflow = StateGraph(ChatState)
    
    # Add nodes with dependency injection
    async def clerk_wrapper(state: ChatState) -> ChatState:
        state_dict = state.model_dump()
        updated = await clerk_node(state_dict, clerk_repo)
        return ChatState(**updated)
    
    workflow.add_node("clerk", clerk_wrapper)
    # Future: add_node("subconscious", ...)
    # Future: add_node("orchestrator", ...)
    
    # Define edges
    workflow.set_entry_point("clerk")
    workflow.add_edge("clerk", END)  # Phase 1
    # Future: workflow.add_edge("clerk", "subconscious")
    
    return workflow.compile()
```

**CRITICAL PATTERNS:**

1. **Wrapper functions –¥–ª—è dependency injection**
   ```python
   # ‚úÖ GOOD
   async def node_wrapper(state: ChatState) -> ChatState:
       deps = get_dependencies()
       state_dict = state.model_dump()
       updated = await node_function(state_dict, deps)
       return ChatState(**updated)
   ```

2. **Dict ‚Üî Pydantic conversion**
   ```python
   # LangGraph –ø—Ä–∞—Ü—é—î –∑ dict
   state_dict = state.model_dump()  # Pydantic ‚Üí dict
   updated_dict = await node(state_dict)
   result = ChatState(**updated_dict)  # dict ‚Üí Pydantic
   ```

---

## Common Pitfalls & Solutions

### Issue 1: workflow.ainvoke() Returns Dict

**Problem:**
```python
final_state = await workflow.ainvoke(initial_state)
# final_state is AddableValuesDict, NOT ChatState!
if final_state.error:  # ‚ùå AttributeError!
```

**Solution:**
```python
final_state_dict = await workflow.ainvoke(initial_state)
final_state = ChatState(**final_state_dict)  # Convert!
if final_state.error:  # ‚úÖ Works
```

**ALWAYS convert dict ‚Üí Pydantic after ainvoke().**

### Issue 2: Shared Mutable Objects

**Problem:**
```python
# ‚ùå BAD - mutable default
class ChatState(BaseModel):
    context: dict = {}  # SHARED between all states!
```

**Solution:**
```python
# ‚úÖ GOOD - factory function
from pydantic import Field

class ChatState(BaseModel):
    context: dict = Field(default_factory=dict)
```

### Issue 3: Blocking Operations in Async Context

**Problem:**
```python
async def node(state):
    result = requests.get(url)  # ‚ùå Blocking!
```

**Solution:**
```python
async def node(state):
    async with httpx.AsyncClient() as client:
        result = await client.get(url)  # ‚úÖ Async
```

**For sync libraries (FalkorDB):**
```python
loop = asyncio.get_event_loop()
result = await loop.run_in_executor(None, sync_function)
```

---

## Initialization Pattern

### Global Workflow Instance

**Location:** `backend/app/main.py`

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    falkordb = await init_falkordb_client()
    
    # Initialize agents
    clerk_repo = MessageRepository(falkordb)
    init_chat_workflow(clerk_repo)
    logger.info("ü§ñ Multi-agent chat system initialized")
    
    yield
    
    # Shutdown
    await close_falkordb_client()

app = FastAPI(lifespan=lifespan)
```

**NEVER:**
- ‚ùå Create workflow per request
- ‚ùå Re-initialize agents
- ‚ùå Share state between requests

**ALWAYS:**
- ‚úÖ Singleton workflow instance
- ‚úÖ Initialize in lifespan
- ‚úÖ Fresh state per request

---

## Error Propagation

### Through State

**Pattern:**
```python
# Agent 1 fails
state["error"] = "Agent 1 failed: reason"
state["agent1_completed"] = False

# Agent 2 checks
if state.get("error"):
    logger.warning("‚ö†Ô∏è Previous agent failed, skipping")
    return state  # Pass through

# Or handle and continue
if state.get("error"):
    logger.info("üîÑ Recovering from error...")
    state["error"] = None  # Clear
    # ... recovery logic ...
```

**Decision:** Fail fast vs graceful degradation?
- **Clerk fails** ‚Üí Fail fast (can't continue without recording)
- **Subconscious fails** ‚Üí Continue (use empty context)
- **Orchestrator fails** ‚Üí Return error to user

---

## Conditional Edges (Future)

### Dynamic Routing

```python
def should_use_tool(state: ChatState) -> str:
    """Decide next node based on state."""
    if "use calculator" in state.message_content.lower():
        return "tool_caller"
    else:
        return "orchestrator"

workflow.add_conditional_edges(
    "subconscious",
    should_use_tool,
    {
        "tool_caller": "tool_caller_node",
        "orchestrator": "orchestrator_node"
    }
)
```

---

## Debugging

### Visualize Workflow

```python
from langchain_core.runnables.graph import MermaidDrawMethod

# Get mermaid diagram
diagram = workflow.get_graph().draw_mermaid()
print(diagram)

# Or draw to file
workflow.get_graph().draw_mermaid_png(
    output_file_path="workflow.png"
)
```

### State Inspection

```python
# In node
logger.debug(f"üìä State: {state}")
logger.debug(f"üìä Keys: {state.keys()}")
logger.debug(f"üìä Message ID: {state.get('message_id', 'N/A')}")
```

---

## Version Compatibility

**LangGraph:** 0.2.28  
**langchain-core:** 0.3.10

**IMPORTANT:** LangGraph API —à–≤–∏–¥–∫–æ –∑–º—ñ–Ω—é—î—Ç—å—Å—è. –ü—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ:
- Check breaking changes
- Test –≤—Å—é flow
- Update rules —è–∫—â–æ patterns –∑–º—ñ–Ω–∏–ª–∏—Å—å

---

## Performance Optimization

### Parallel Execution (Future)

For independent agents:
```python
from langgraph.graph import StateGraph, END

# Instead of sequential
workflow.add_edge("clerk", "subconscious")

# Parallel (if agents independent)
workflow.add_edge("clerk", ["analyzer", "summarizer"])
workflow.add_edge(["analyzer", "summarizer"], "orchestrator")
```

**Use when:** Agents don't depend on each other's outputs.

---

## Resources

**Official Docs:** https://langchain-ai.github.io/langgraph/  
**Examples:** https://github.com/langchain-ai/langgraph/tree/main/examples  
**Our Implementation:** `backend/app/agents/`

---

**Version:** 1.0.0  
**Last Updated:** November 6, 2025  
**Status:** Phase 1 patterns documented
