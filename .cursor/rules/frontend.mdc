---
description: Frontend TypeScript standards
alwaysApply: false
---
# TYPESCRIPT STANDARDS

## Project Structure
```
frontend/
├── src/
│   ├── components/   # React components
│   ├── services/     # API clients
│   ├── hooks/        # Custom hooks
│   ├── types/        # TypeScript types
│   ├── utils/        # Helpers
│   └── config/       # Configuration
├── public/
└── tests/
```

## Type Safety
- Enable `strict` mode in tsconfig.json
- Use `unknown` instead of `any`
- Define interfaces for all data structures
- Use discriminated unions for state

```typescript
// Good: Discriminated union
type LoadingState =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: Data }
  | { status: 'error'; error: Error };

// Good: Proper typing
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  // Implementation
}
```

## Async Patterns
- Use async/await consistently
- Implement proper error boundaries
- Handle loading states explicitly
- Use AbortController for cancellable requests

```typescript
// API client with abort support
class ApiClient {
  private controller: AbortController | null = null;

  async fetch<T>(endpoint: string): Promise<T> {
    this.controller = new AbortController();

    try {
      const response = await fetch(endpoint, {
        signal: this.controller.signal
      });
      return await response.json();
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Request cancelled');
      }
      throw error;
    }
  }

  cancel() {
    this.controller?.abort();
  }
}
```

## Component Patterns
```typescript
// Modular component structure
interface ComponentProps {
  data: Data;
  onAction: (id: string) => Promise<void>;
}

export const Component: React.FC<ComponentProps> = ({ data, onAction }) => {
  const [loading, setLoading] = useState(false);

  const handleAction = async (id: string) => {
    setLoading(true);
    try {
      await onAction(id);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  return (/* JSX */);
};
```

## Module Organization
- One component per file
- Co-locate tests with components
- Export types separately
- Use barrel exports (index.ts)

### Component Modularity

**Pattern:** Split large features into reusable sub-components

```
feature/
├── MainForm.tsx           # Main component
├── fields/                # Sub-components by type
│   ├── TextField.tsx
│   ├── NumberField.tsx
│   ├── EnumField.tsx
│   └── FieldRenderer.tsx  # Dynamic dispatcher
├── Editor.tsx             # Related component
└── Manager.tsx            # Management UI
```

**Real Example from Template System:**

```
components/falkordb/
├── NodeTemplateForm.tsx       # Main form - uses TemplateFieldRenderer
├── TemplateEditor.tsx         # Template creation/editing
├── TemplateManager.tsx        # Template management UI
└── fields/                    # 10 isolated field components
    ├── FieldWrapper.tsx       # Common wrapper
    ├── TextField.tsx
    ├── LongTextField.tsx
    ├── NumberField.tsx
    ├── BooleanField.tsx
    ├── EnumField.tsx
    ├── DateField.tsx
    ├── UrlField.tsx
    ├── EmailField.tsx
    └── TemplateFieldRenderer.tsx  # Dispatches to specific component
```

**Benefits:**
- ✅ Reusability - each field type is self-contained
- ✅ Easy testing - test one field type at a time
- ✅ Type safety - each component has strict props
- ✅ Clear separation of concerns

**Dynamic Rendering Pattern:**
```typescript
// TemplateFieldRenderer.tsx
export const TemplateFieldRenderer = ({ field, value, onChange }) => {
    switch (field.type) {
        case 'text':
            return <TextField field={field} value={value} onChange={onChange} />;
        case 'number':
            return <NumberField field={field} value={value} onChange={onChange} />;
        case 'enum':
            return <EnumField field={field} value={value} onChange={onChange} />;
        // ... all types
        default:
            return <TextField field={field} value={value} onChange={onChange} />;
    }
};
```

**RULE:** For features with multiple variants (field types, view modes, etc.), create:
1. Individual components for each variant
2. Central dispatcher component that delegates based on type/mode
3. Common wrapper for shared styling/behavior

## Vite Environment Variables

### Type definitions for import.meta.env
```typescript
// src/vite-env.d.ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL?: string;
  readonly VITE_APP_TITLE?: string;
  readonly VITE_DEBUG?: string;
  // Add more env variables here
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

**Rule:** ALWAYS create `vite-env.d.ts` when using `import.meta.env`.

### Environment variable naming
```typescript
// GOOD: Prefixed with VITE_
VITE_API_URL=http://localhost:8000
VITE_DEBUG=true

// BAD: Will not be exposed to client
API_URL=http://localhost:8000
DEBUG=true
```

**Rule:** All client-side env variables MUST be prefixed with `VITE_`.

### Usage in code
```typescript
// API client
const API_BASE_URL = import.meta.env.VITE_API_URL || '/api';

// Feature flags
const isDebugMode = import.meta.env.VITE_DEBUG === 'true';

// Mode-specific behavior
if (import.meta.env.DEV) {
  console.log('Running in development mode');
}
```

### Default values
```typescript
// .env.example
VITE_API_URL=/api
VITE_APP_TITLE=My App

// .env.local (gitignored)
VITE_API_URL=http://localhost:8000
```

**Rule:** Provide sensible defaults and document all env variables in `.env.example`.

## Layout & Styling Guidelines

### Content Readability
- Preserve readability for long-form content (e.g., raw JSON) by applying `white-space: pre-wrap` and `word-break: break-word` in any scrollable `<pre>`/`<code>` blocks.
- Prefer responsive wrappers over forcing horizontal scroll for critical text blocks.

### Form Input Visibility

**CRITICAL:** Always ensure text is visible in form inputs!

**Problem from production:**
- Light text on light background → can't read what you type
- Dark text on dark background → same problem

**Solution:**
```css
/* GOOD: High contrast */
.field-input,
.field-textarea,
.field-select {
    background: white;
    color: #1f2937;  /* Dark text on light background */
    border: 2px solid #e5e7eb;
}

/* For dark theme pages */
.dark-theme .field-input {
    background: #1f2937;
    color: #f1f5f9;  /* Light text on dark background */
}
```

**ALWAYS:**
- Test inputs by actually typing text
- Ensure sufficient contrast (WCAG AA minimum: 4.5:1)
- Check both empty and filled states
- Test on actual background colors used in UI

**Common mistakes:**
- ❌ Inheriting color from parent without explicit override
- ❌ Using CSS variables without checking actual computed color
- ❌ Testing only with placeholder text (different color from value)

**Testing checklist:**
- [ ] Type text in input - can you read it?
- [ ] Select dropdown option - is it visible?
- [ ] Fill textarea - is text readable?
- [ ] Check on actual page background (not isolation)

## Build Verification
- Always run `npm run build` (production build) before submitting changes to catch `tsc` warnings, unused symbols, and Vite-specific issues.
- CI pipelines should execute the same command to guard against regressions introduced by environment variables or tree-shaking.

## Error Handling in Components

### Error boundaries
```typescript
import { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>Something went wrong</div>;
    }
    return this.props.children;
  }
}
```

### Async error handling in components
```typescript
const Component: React.FC = () => {
  const [error, setError] = useState<string | null>(null);

  const handleAction = async () => {
    try {
      setError(null);
      await apiCall();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      setError(message);
    }
  };

  return (
    <>
      {error && <ErrorMessage message={error} onDismiss={() => setError(null)} />}
      <button onClick={handleAction}>Action</button>
    </>
  );
};
```

**Rule:** ALWAYS handle async errors in components explicitly.