---
description: Architectural principles and async-first guidelines for all services
alwaysApply: false
---
# ARCHITECTURAL PRINCIPLES

## SOLID Principles (Strict Adherence)

### Single Responsibility
```python
# BAD: Class doing too much
class UserManager:
    def create_user(self): pass
    def send_email(self): pass
    def log_activity(self): pass

# GOOD: Separated concerns
class UserRepository:
    async def create(self, user: User) -> User: pass

class EmailService:
    async def send(self, to: str, subject: str): pass

class ActivityLogger:
    async def log(self, event: str): pass
```

### Open/Closed Principle
```python
from abc import ABC, abstractmethod

class DataProcessor(ABC):
    @abstractmethod
    async def process(self, data: dict) -> dict:
        pass

class JSONProcessor(DataProcessor):
    async def process(self, data: dict) -> dict:
        # JSON-specific logic
        pass

class XMLProcessor(DataProcessor):
    async def process(self, data: dict) -> dict:
        # XML-specific logic
        pass
```

### Dependency Inversion
```python
# BAD: Direct dependency
class Service:
    def __init__(self):
        self.db = PostgresDatabase()  # Tight coupling

# GOOD: Depend on abstraction
from typing import Protocol

class Database(Protocol):
    async def query(self, sql: str) -> list: ...

class Service:
    def __init__(self, db: Database):
        self.db = db  # Loose coupling
```

## Modular Architecture

### Module Structure
```
feature/
├── __init__.py       # Public API
├── models.py         # Data models
├── service.py        # Business logic
├── repository.py     # Data access
├── schemas.py        # Validation schemas
└── tests/
    ├── test_service.py
    └── test_repository.py
```

### Module Pattern
```python
# __init__.py - Define public API
from .service import FeatureService
from .models import FeatureModel

__all__ = ["FeatureService", "FeatureModel"]

# Other modules are internal implementation
```

## Async-First Development

### Rules
1. **ALL I/O operations MUST be async**
2. Use `asyncio.gather()` for parallel operations
3. Implement proper timeout handling
4. Use connection pools for databases
5. Avoid blocking calls in async context

### Pattern Template
```python
import asyncio
from typing import List

class AsyncService:
    def __init__(self, db, cache, api_client):
        self.db = db
        self.cache = cache
        self.api = api_client

    async def fetch_data(self, ids: List[str]) -> List[dict]:
        # Parallel async operations
        tasks = [
            self._fetch_from_cache(id),
            self._fetch_from_db(id),
            self._fetch_from_api(id)
        ]

        results = await asyncio.gather(
            *tasks,
            return_exceptions=True
        )

        return self._merge_results(results)

    async def _fetch_with_timeout(self, coro, timeout: float = 5.0):
        try:
            return await asyncio.wait_for(coro, timeout=timeout)
        except asyncio.TimeoutError:
            # Handle timeout
            return None
```

## Error Handling Strategy

### Layered Error Handling
```python
# Custom exceptions
class DomainException(Exception):
    """Base for domain errors"""
    pass

class ValidationError(DomainException):
    """Validation failures"""
    pass

class NotFoundError(DomainException):
    """Resource not found"""
    pass

# Service layer
class Service:
    async def process(self, data: dict):
        try:
            validated = await self._validate(data)
            result = await self._execute(validated)
            return result
        except ValidationError as e:
            # Log and re-raise domain errors
            logger.warning(f"Validation failed: {e}")
            raise
        except Exception as e:
            # Convert unknown errors to domain errors
            logger.error(f"Unexpected error: {e}", exc_info=True)
            raise DomainException("Processing failed") from e

# API layer
@app.exception_handler(ValidationError)
async def validation_handler(request, exc):
    return JSONResponse(
        status_code=422,
        content={"detail": str(exc)}
    )
```

## Testing Requirements
- Unit tests for all services
- Integration tests for API endpoints
- Mock external dependencies
- Use pytest with async support
- Minimum 80% coverage for critical paths

```python
import pytest
from unittest.mock import AsyncMock

@pytest.mark.asyncio
async def test_service_method():
    # Arrange
    mock_db = AsyncMock()
    mock_db.query.return_value = [{"id": 1}]
    service = Service(db=mock_db)

    # Act
    result = await service.fetch_data("1")

    # Assert
    assert result["id"] == 1
    mock_db.query.assert_called_once()
```